package com.konylabs.js.appsrc;

import com.konylabs.js.appsrc.KonyJavaScriptSource;

public class PaaSLicenseSource extends KonyJavaScriptSource {
	
	public String getSourceName(){
		return "PaaSLicenseSource";
	}
	
	public String[] getSource(){
		return new String[]{"/*\n *\n *  File      : license.js\n *  Version   : 8.3.1.0\n *  TimeStamp : 27-07-2018 14:50:53 IST\n *\n */\n\nkony.license = {};\nvar appConfig = undefined;\nkony.license.disableMetricReporting = function() {\n    kony.ds.save([\"true\"], \"LicenseDisableFlag\");\n}\n\nkony.licensevar = {};\nkony.licensevar.didAppWentInBackground = false;\nkony.license.timeoutValue = 14400 ;\nkony.licensevar.currentSessionId = \"\";\nkony.licensevar.latestSessionCreationTimestamp = \"\";\nkony.licensevar.maxSessionCountLimit = 100;\nkony.licensevar.changeHandlers = [];\nkony.licensevar.isLicenseUrlAvailable = true;\nkony.licensevar.isISTNetworkCallProcessingInProgress = false;\nkony.licensevar.deferredNewSessionsCounter = 0;\nkony.license.maxWaitTimeToHandleMultipleNewSessions = 60;\n\n/*\n *  Name      : kony.license.setLogging\n *  Purpose   : The API enables the logs for license.js. \n *              It should be called via devloper who is intented to debug the license flow. It can be called in the app code or through developer tools.\n *  Scenarios : i) If kony.license.setLogging is invoked with boolean value true , the logs will be enabled for current launch and further launch of the app\n *              ii) If kony.license.setLogging is invoked with boolean value false , the logs will be disabled for current launch and further launch of the app\n */\nkony.license.setLogging = function(boolValue){\n    if(boolValue === true){\n        kony.ds.save([true], \"LicenseLoggingFlag\");\n    }else{\n        kony.ds.save([false], \"LicenseLoggingFlag\");\n    }\n}\n\nkony.license.log = function(msg){\n    try{\n        var logCondition = kony.ds.read(\"LicenseLoggingFlag\");\n    }catch(e){\n        //This might get into exception in case of SPA due to a limitaion in implementation of FTR MADPSPA-394\n    }\n    if (logCondition != undefined && logCondition[0] != undefined && logCondition[0]!=null && logCondition[0]===true) {\n        kony.print(\"[License] :\"+msg);\n    }\n}\n\nkony.license.isLicenseUrlAvailable = function() {\n    return kony.licensevar.isLicenseUrlAvailable;\n}\n\nkony.license.setIsLicenseUrlAvailable = function(value) {\n    kony.licensevar.isLicenseUrlAvailable = value;\n}\n\nkony.license.getSessionId = function() {\n    return kony.licensevar.currentSessionId;\n}\n\nkony.license.registerChangeListener = function(changeHandler) {\n\n    if (!changeHandler) {\n        return;\n    }\n    // We give the initial values once\n    var changes = {};\n    var userId = kony.ds.read(\"konyUserID\");\n    changes[\"sessionId\"] = kony.licensevar.currentSessionId;\n    if (userId != undefined && userId[0] != undefined && userId[0]!=null) {\n        changes[\"userId\"] = userId[0];\n    }\n    changeHandler(changes);\n\n    // Add to my listeners\n    kony.licensevar.changeHandlers.push(changeHandler);\n};\n\nkony.license.notifyChangesToListeners = function() {\n    for (var i = 0; i < kony.licensevar.changeHandlers.length; i++) {\n        var changes = {};\n        var userId = kony.ds.read(\"konyUserID\");\n        changes[\"sessionId\"] = kony.licensevar.currentSessionId;\n        if (userId != undefined && userId[0] != undefined && userId[0]!=null) {\n            changes[\"userId\"] = userId[0];\n        }\n        var changeHandler = kony.licensevar.changeHandlers[i];\n        changeHandler(changes);\n    }\n};\n\n/*\n*  Name      : processDeferredNewSessions\n*  Author    : None\n*  Purpose   : Helper method to process deferred new sessions\n*/\n\nkony.license.processDeferredNewSessions = function () {\n    kony.license.log(\"sending deferred launch date - \"+kony.licensevar.currentSessionId);\n    kony.licensevar.isISTNetworkCallProcessingInProgress = false;\n    kony.licensevar.deferredNewSessionsCounter = 0;\n    kony.license.captureKonyLicenseUsage(true);\n}\n\n\n/*\n *  Name      : kony.license.startLicenseService\n *  Author    : None\n *  Purpose   : Single global function which contains definitions of all required functions for session tracking.\n */\nkony.license.startLicenseService = function() {\n        \"use strict\";\n        var deviceInfo = kony.os.deviceInfo();\n        kony.license.log(\"startLicenseService deviceInfo \" + JSON.stringify(deviceInfo));\n        /*\n         *  Name      : getLicenseUrl\n         *  Author    : None\n         *  Purpose   : Internal function to get the appropriate IST url for session calls\n         */\n\n        function getLicenseUrl() {\n            var url = \"\";\n            if (appConfig.isturlbase) {\n                url = appConfig.isturlbase + \"/IST\";\n            } else if (appConfig.secureurl) {\n                url = getFromServerUrl(appConfig.secureurl, \"IST\");\n            } else if (appConfig.url) {\n                url = getFromServerUrl(appConfig.url, \"IST\");\n            }\n            return url;\n        }\n\n       \n        /*\n         *  Name      : getFromServerUrl\n         *  Author    : None\n         *  Purpose   : Helper method to form a proper url\n         */\n\n        function getFromServerUrl(url, path) {\n            if (!url) {\n                return null;\n            }\n            // ServerURL for non-mf has /mwservlet appended after the context path.\n            // We need to remove it to get the base server url\n            kony.license.log(\"Entering into getfromserverurl when IST-base url is not defined\");\n            if (deviceInfo.name === \"thinclient\") {\n                url = url.replace(/mwservlet\\/*$/i, \"\");\n                return url + path;\n            } else {\n                var exactSubString = url.match(/mwservlet/i);\n                var newUrl = null;\n                if (exactSubString) {\n                    var exactSubStringLength = \"mwservlet\".length;\n                    var lastSubStringIndex = url.lastIndexOf(exactSubString);\n                    var subString = url.slice(0, lastSubStringIndex);\n                    var index = (lastSubStringIndex + exactSubStringLength);\n                    var subString2 = url.slice(index, url.length);\n                    var has = /[a-zA-Z0-9]/.test(subString2);\n                    if (!has) {\n                        newUrl = subString;\n                    } else {\n                        newUrl = url;\n                    }\n                } else {\n                    newUrl = url;\n                }\n                return newUrl + path;\n            }\n        }\n\n        function getApplicationType(name) {\n            if (name === \"thinclient\") {\n                return \"spa\";\n            }\n            var appMode = kony.application.getApplicationMode();\n            if (appMode === constants.APPLICATION_MODE_NATIVE) {\n                return \"native\";\n            } else if (appMode === constants.APPLICATION_MODE_HYBRID) {\n                return \"hybrid\";\n            } else if (appMode === constants.APPLICATION_MODE_WRAPPER) {\n                return \"mixedmode\";\n            } else {\n                return \"\";\n            }\n        }\n\n        /*\n         *  Name       : kony.setUserID\n         *  Author     : None\n         *  Purpose    : Stores the userID in device local, once set.\n         *  Scenarios :  i) If kony.setUserID api is invoked by the developer, the userId set won't be overriden regardless \n         *                   of any number of logins.\n         *               ii) If kony.setUserID is called from login flow, then the userId of login will be set and will \n         *                    be overriden for every subsequent login calls and direct invocation of kony.setUserID.\n         *               iii) kony.setUserID api is invoked by the developer the userId for ex: 'X' will be set, again if kony.setUserID \n         *                    api is invoked with value ex : 'Y' then the previous value will be overriden and \n         *                    current userId will be set to 'Y'.\n         */\n\n        kony.setUserID = function(userId,fromLoginFlag) {\n            /* fromLoginFlag is introduced to know whether the call is made from\n               login flow or directly kony.setUserID api is invoked */\n\t\t\tif(fromLoginFlag == undefined || fromLoginFlag == null){\n\t\t\t\tfromLoginFlag = false;\n\t\t\t}\n            var user = new Array;\n            user.push(userId);\n            var userIDflagGet = kony.ds.read(\"userIDFromLicenseFlag\");\n             /* If userIDflagGet is true ie. it is being set by invoking kony.setUserID directly and this function \n               is invoked from login flow, then no need to override, just return */\n            if(userIDflagGet && (userIDflagGet[0] == \"true\") && fromLoginFlag) {\n                return;\n            }\n\n            /* If the invocation is directly through calling api and not through login flow,\n               set userIDFromLicenseFlag key to true so that it is not overriden by any other invocations from login flow*/\n\n            /* userIDFromLicenseFlag is set to true only when kony.setUserID api is directly invoked by the developer */\n            if(!fromLoginFlag) {\n                var userIDflagSet = new Array;\n                userIDflagSet.push(\"true\");\n                kony.ds.save(userIDflagSet,\"userIDFromLicenseFlag\");\n            }\n\n            /* sets userID in device local */\n            kony.ds.save(user, \"konyUserID\");\n            kony.license.notifyChangesToListeners();\n        }\n\n        kony.license.generateUUID = function() {\n                var S4 = function() {\n                    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n                };\n                return (new Date().getTime() + '-' + S4() + '-' + S4() + '-' + S4());\n        }\n        /*\n         *  Name      : kony.license.isCloud\n         *  Author    : None\n         *  Purpose   : Returns true if it is cloud enviroment, else returns false.\n         */\n        kony.license.isCloud = function() {\n                //starting 6.0 the licensing approach is also applicable for On-Prem customers.Hence the license usage posting \n                //will be enabled for on-prem customers as well. So removing the check for the Kony Cloud URLs.\n\n                var isLicenseEnabled = true;\n                var LicenseCheck = kony.ds.read(\"LicenseDisableFlag\");\n                if (LicenseCheck && (LicenseCheck[0] === \"true\" || LicenseCheck === \"true\" ))  {\n                    isLicenseEnabled = false;\n                }\n                if (kony.license.isLicenseUrlAvailable() === false) {\n                    isLicenseEnabled = false;\n                }\n                return isLicenseEnabled;\n        }\n\n        /*\n         *  Name      : kony.license.getCurrentDateTime\n         *  Author    : None\n         *  Purpose   : Returns current date and time details in required string format for service input.\n         */\n        kony.license.getCurrentDateTime = function() {\n                kony.license.log(\"getCurrentDateTime..\");\n                var nowDate, month, formatDate;\n                nowDate = new Date();\n                month = new Date().getUTCMonth() + 1;\n                formatDate = ((\"00\" + nowDate.getUTCFullYear()).slice(-4)) + \"-\" + ((\"00\" + month).slice(-2)) + \"-\" + ((\"00\" + nowDate.getUTCDate()).slice(-2)) + \" \" + ((\"00\" + nowDate.getUTCHours()).slice(-2)) + \":\" + ((\"00\" + nowDate.getUTCMinutes()).slice(-2)) + \":\" + ((\"00\" + nowDate.getUTCSeconds()).slice(-2));\n                return formatDate;\n        }\n\n        /*\n         *  Name      : kony.license.appendLicenseTrackingKeys\n         *  Author    : None\n         *  Purpose   : Returns input object after appending the required tracking keys for provided input object.\n         */\n\n        kony.license.appendLicenseTrackingKeys = function(requestType,reportData) {\n                kony.license.log(\"appendLicenseTrackingKeys deviceinfo ---> \" + JSON.stringify(deviceInfo));\n                var inputParams = {};\n                 if (kony.license.isCloud() === true) {\n                    inputParams.plat = deviceInfo.name;\n                    if (typeof(kony.sdk) !== \"undefined\"){\n                        inputParams.chnl = kony.sdk.getChannelType();\n                        inputParams.did = kony.sdk.getDeviceId();\n                        inputParams.plat = kony.sdk.getPlatformName();    \n                    }\n                    else{\n                        //In absense of sdk [ MFSDK-2377 ],since for 7.0 viz we do not package SDK, so sdk namespace won't be available\n                        //We should be okay with this hardcoding because in absence of SDK, IST call also doesn't make sense\n                        //We are making this fix just for Backward compatibility of Viz Starter 7.0 Apps.\n                        inputParams.chnl = \"fpApp\";\n                        inputParams.did = \"fp-\"+kony.license.generateUUID();\n                        inputParams.plat = \"fp\";\n                    }\n                    \n                    inputParams.aid = appConfig.appId;\n                    inputParams.aver = appConfig.appVersion;\n                    inputParams.aname = appConfig.appName;\n                    //adding mfaid, mfaname if konyref is available.\n                    if (typeof konyRef !== \"undefined\" && konyRef != null && konyRef.mainRef) {\n                        inputParams.mfaid = konyRef.mainRef.appId;\n                        inputParams.mfbaseid = konyRef.mainRef.baseId;\n                        inputParams.mfaname = konyRef.mainRef.name;\n                    }\n                    if (kony.application.getCurrentForm()) {\n                        var fid = kony.application.getCurrentForm().id;\n                        if (fid) {\n                            inputParams.fid = fid;\n                        }\n                    }\n                    inputParams.atype = getApplicationType(deviceInfo.name);\n                    inputParams.os = deviceInfo.version;\n                    inputParams.stype = \"b2c\";\n                    inputParams.dm = deviceInfo.model;\n                    inputParams.ua = kony.os.userAgent();\n\n                    var userId = kony.ds.read(\"konyUserID\");\n                    if (userId !== undefined && userId !== null && userId.length > 0) {\n                        inputParams.kuid = userId[0];\n                    } else {\n                        inputParams.kuid = \"\";\n                    }\n                    if (requestType === \"session\") {\n                        //Getting the offline access time details and passing as input to service\n                        kony.license.checkAndCreateSession();\n                        var uuid = kony.licensevar.currentSessionId;\n                        var offlineData = kony.ds.read(\"konyOfflineAccessData\");\n                        if (offlineData === undefined || offlineData === null) {\n                            offlineData = new Array();\n                        }\n                        var currentSession = new Array();\n                        currentSession.push(uuid);\n                        currentSession.push(kony.licensevar.latestSessionCreationTimestamp);\n                        if(kony.licensevar.isISTNetworkCallProcessingInProgress === true || kony.licensevar.deferredNewSessionsCounter > 0){\n                            //In case of first app laucn the kony.licensevar.deferredNewSessionsCounter would be 0 , so we don't need to cancel the uncommenced timer\n                            if(kony.licensevar.deferredNewSessionsCounter > 0) {\n                                try{\n                                    kony.license.log(\"cancelling the previous timer, as in span of \"\n                                        +kony.license.maxWaitTimeToHandleMultipleNewSessions+ \" seconds, a new IST was fired immediately\");\n                                    kony.timer.cancel(\"konySession\"+(kony.licensevar.deferredNewSessionsCounter-1));\n                                } catch(erObj) {\n                                    kony.license.log(\"error - \"+JSON.stringify(erObj)+\",  while cancelling the deferred session timer\" +\n                                        \" to send launch dates with timer id\"+(kony.licensevar.deferredNewSessionsCounter-1));\n                                }\n                            }\n                            kony.timer.schedule((\"konySession\"+(kony.licensevar.deferredNewSessionsCounter++)),\n                                kony.license.processDeferredNewSessions, kony.license.maxWaitTimeToHandleMultipleNewSessions, false);\n                                kony.license.log(\"another session is in progress , we will try again\");\n                            return {}; //returning empty konyReportingParams as we dont want another IST call while one IST call is in progress\n                        }\n                        \n                        if(offlineData.length === 0 || offlineData[(offlineData.length-1)][0] !== currentSession[0]){\n                            offlineData.push(currentSession);\n                        }else{\n                            kony.license.log(\"Ignoring duplicate session: \"+JSON.stringify(currentSession));\n                        }\n                        if(offlineData.length > kony.licensevar.maxSessionCountLimit){\n                            kony.license.log(\"Trimming to latest \" + kony.licensevar.maxSessionCountLimit + \" records, total records found - \" + offlineData.length);\n                            var sliceValue = offlineData.length - kony.licensevar.maxSessionCountLimit;\n                            offlineData = offlineData.slice(sliceValue);\n                        }\n                        kony.ds.save(offlineData, \"konyOfflineAccessData\");\n                        inputParams.launchDates = offlineData;\n                        kony.licensevar.isISTNetworkCallProcessingInProgress = true;\n                        inputParams.svcid = \"RegisterKonySession\";\n                        kony.license.log(\"---------->LaunchDates : \" + inputParams.launchDates);\n                    } else {\n                        var uuid = kony.ds.read(\"konyUUID\");\n                        if (uuid !== undefined && uuid !== null && uuid.length > 0) {\n                            inputParams.rsid = uuid[0];\n                        } else {\n                            inputParams.rsid = kony.license.generateUUID().toString();\n                        }\n                    }\n                }\n                kony.license.log(\"input params in appendLicenseTrackingKeys are \" + JSON.stringify(inputParams));\n                return inputParams;\n            \n        }\n\n        /*\n         *  Name      : kony.license.checkAndCreateSession\n         *  Author    : None\n         *  Purpose   : creates a new session (if session is not created).\n         */\n        kony.license.checkAndCreateSession = function() {\n                kony.license.log(\"check and create session..\");\n                var uuid = kony.ds.read(\"konyUUID\");\n                if (uuid !== undefined && uuid !== null && uuid.length > 0) {\n                   kony.licensevar.currentSessionId = uuid[0];\n                } else {\n                   kony.license.createSession();\n                } \n        }\n\n        /*\n         *  Name      : kony.license.createSession\n         *  Author    : None\n         *  Purpose   : creates a new session (if session is not created) and sets the counter for 4hrs to call IST.\n         */\n        var sdkTimerCounter = 0 ;\n        kony.license.createSession = function() {\n            //In case of first app laucn the sdkTimerCounter would be 0 , so we don't need to cancel the uncommenced timer\n            if(sdkTimerCounter != 0) {\n                try{\n                    kony.timer.cancel(\"konyLicenseTimeout\"+(sdkTimerCounter-1));\n                } catch(erObj) {\n                    kony.license.log(\"the error object while cancelling the timer is\"+ erObj);\n                }\n            }\n            var uuid = new Array();\n            kony.licensevar.currentSessionId = kony.license.generateUUID().toString();\n            kony.licensevar.latestSessionCreationTimestamp = kony.license.getCurrentDateTime();\n            uuid.push(kony.licensevar.currentSessionId);\n            kony.ds.save(uuid, \"konyUUID\");\n            kony.license.notifyChangesToListeners();\n            kony.timer.schedule((\"konyLicenseTimeout\"+(sdkTimerCounter++)),kony.license.sendNewIST,kony.license.timeoutValue,false);\n        }\n\n            \n        kony.license.sendNewIST = function() {\n            kony.license.createSession();\n            kony.license.captureKonyLicenseUsage(true);           \n        }\n        \n        /*\n         *  Name      : kony.license.licenseUsageServiceSuccessCallback\n         *  Author    : KH2321\n         *  Purpose   : handles the success behaviour of IST call and clear the offline stored failed sid\n         */\n        kony.license.licenseUsageServiceSuccessCallback = function (result){\n                kony.licensevar.isISTNetworkCallProcessingInProgress = false;\n                kony.license.log(\"launch dates sent successfully. result - \"+JSON.stringify(result));\n                //If launchDetails are successfully logged at server. Removing offline access details.\n                kony.ds.remove(\"konyOfflineAccessData\");\n                kony.ds.remove(\"konyOfflineSessionsCount\");\n        }\n\n        /*\n         *  Name      : kony.license.licenseUsageServiceFailureCallback\n         *  Author    : KH2321\n         *  Purpose   : handles the error behaviour of IST call and stores failed sid\n         */\n        kony.license.licenseUsageServiceFailureCallback = function(result)\n        {       \n                kony.licensevar.isISTNetworkCallProcessingInProgress = false;\n                kony.license.log(\"launch dates weren't sent successfully. result - \"+JSON.stringify(result));\n                //Storing offline access time details in case of network/service issues.\n                var count, offlineCount;\n                //Storing the offline sessions count.\n                offlineCount = kony.ds.read(\"konyOfflineSessionsCount\");\n                if (offlineCount === undefined || offlineCount === null || offlineCount.length < 1) {\n                    offlineCount = new Array();\n                    offlineCount.push(1);\n                } else if (!(offlineCount[0] >= 500)) {\n                    //Stop updating the count if greater than 500\n                    count = offlineCount[0] + 1;\n                    offlineCount[0] = count;\n                }\n                kony.ds.save(offlineCount, \"konyOfflineSessionsCount\");\n            }\n        /*\n         *  Name      : kony.license.captureKonyLicenseUsage\n         *  Author    : None\n         *  Purpose   : Makes service call for session tracking if the app is built with cloud environment and last access is made 30 minutes ago.\n         *              Sends required tracking keys for the service.\n         */\n        kony.license.captureKonyLicenseUsage = function(newLaunch) {\n                kony.license.log(\"capturing license information..\");\n                //Count session only if the time difference between last access and current access is more than 1 minute (30 minutes)\n                var nowDate, lastDate, diff, sessionURL;\n                var timeCheck = 1800000;\n                var isNewSession = true;\n                if (newLaunch === undefined || newLaunch === null) {\n                    newLaunch = false;\n                } else if (newLaunch !== true) {\n                    newLaunch = false;\n                }\n                if (kony.license.isCloud() === false) {\n                    kony.license.log(\"session tracking is turned off\");\n                    isNewSession = false;\n                }\n                if (kony.ds.read(\"konyLastAccessTime\") !== undefined && kony.ds.read(\"konyLastAccessTime\") !== null) {\n                    nowDate = new Date();\n                    lastDate = new Date(kony.ds.read(\"konyLastAccessTime\")[0]);\n                    diff = nowDate.getTime() - lastDate.getTime();\n                    if (diff < timeCheck && newLaunch === false) {\n                        isNewSession = false;\n                    } else {\n                        kony.ds.remove(\"konyLastAccessTime\");\n                        if (deviceInfo.name !== \"thinclient\") {\n                            var uuid = kony.ds.read(\"konyUUID\");\n                            if (uuid !== undefined && uuid !== null && uuid.length > 0) {\n                                kony.ds.remove(\"konyUUID\");\n                            }\n                        }\n                    }\n                }\n\n                if (isNewSession === true) {\n                    var input = {};\n                    var options = {};\n                    if (deviceInfo.name !== \"thinclient\") {\n                        options[\"httpRequestOptions\"] = [];\n                        options[\"httpRequestOptions\"][\"timeoutIntervalForRequest\"]=60;  \n                    }\n                    sessionURL = getLicenseUrl();\n                    input.konyreportingparams = JSON.stringify(kony.license.appendLicenseTrackingKeys(\"session\"),null);\n                    options[\"disableIntegrity\"] = true;\n                    if(input.konyreportingparams !== \"{}\"){\n                        kony.license.invokeIST(sessionURL, input, kony.license.licenseUsageServiceSuccessCallback, kony.license.licenseUsageServiceFailureCallback, options);\n                    }\n                }\n        }\n\n        /*\n         *  Name      : kony.license.backgroundTimeCapture\n         *  Author    : None\n         *  Purpose   : Stores the time stamp when app is sent to background.\n         */\n        kony.license.backgroundTimeCapture = function() {\n                kony.license.log(\"app is going to background..\");\n                if (kony.license.isCloud() === true) {\n                    var accessDetails = new Array();\n                    accessDetails.push(new Date().toString());\n                    kony.ds.save(accessDetails, \"konyLastAccessTime\");\n                }\n        }\n\n        /*\n         *  Name      : kony.license.clearLastAccess\n         *  Author    : None\n         *  Purpose   : Clears last access details on the termination of app.\n         */\n        kony.license.clearLastAccess = function() {\n                kony.license.log(\"clear last access..\");\n                if (kony.license.isCloud() === true) {\n                    kony.ds.remove(\"konyLastAccessTime\");\n                }\n        }\n\n        /*\n         *  Name      : kony.license.setAppCallbacksOverride\n         *  Author    : None\n         *  Purpose   : Overrides the API setApplicationCallbacks. Prepends onforeground, onbackground and onappterminate events with required\n         *              session tracking methods.\n         */\n        kony.license.setAppCallbacksOverride = function() {\n                kony.license.log(\"overriding kony.application.setApplicationCallbacks..\");\n                var oldImplementation = kony.application.setApplicationCallbacks;\n\n                function newImplementation(eventsDefinition) {\n                    if (kony.license.isCloud() === true) {\n                        if (eventsDefinition !== undefined && eventsDefinition !== null) {\n                            if (eventsDefinition.onforeground !== undefined && eventsDefinition.onforeground !== null) {\n                                var userForeFunction = eventsDefinition.onforeground;\n                                var newForeFunction = function() {\n                                    if(kony.licensevar.didAppWentInBackground === true){\n                                        kony.license.captureKonyLicenseUsage(false);\n                                    }\n                                    if (deviceInfo.name !== \"thinclient \" && typeof(kony.sync) !== \"undefined\") {\n                                        kony.sync.isAppInBackground = false;\n                                    }\n                                    kony.licensevar.didAppWentInBackground = false;\n                                    userForeFunction();\n                                };\n                                eventsDefinition.onforeground = newForeFunction;\n                            }\n                            if (eventsDefinition.onbackground !== undefined && eventsDefinition.onbackground !== null) {\n                                var userBackFunction = eventsDefinition.onbackground;\n                                var newBackFunction = function() {\n                                    kony.licensevar.didAppWentInBackground = true;\n                                    kony.license.backgroundTimeCapture();\n                                    if (typeof(kony.sdk) !== \"undefined\" && typeof(kony.sdk.metric) !== \"undefined\") {\n                                        kony.sdk.metric.saveInDS();\n                                    }\n                                    if (deviceInfo.name !== \"thinclient \" && typeof(kony.sync) !== \"undefined\") {\n                                        kony.sync.isAppInBackground = true;\n                                    }\n                                    userBackFunction();\n                                };\n                                eventsDefinition.onbackground = newBackFunction;\n                            }\n                            if (eventsDefinition.onappterminate !== undefined && eventsDefinition.onappterminate !== null) {\n                                var userTerminateFunction = eventsDefinition.onappterminate;\n                                var newTerminateFunction = function() {\n                                    kony.license.clearLastAccess();\n                                    if (typeof(kony.sdk) !== \"undefined\" && typeof(kony.sdk.metric) !== \"undefined\") {\n                                        kony.sdk.metric.saveInDS();\n                                    }\n                                    userTerminateFunction();\n                                };\n                                eventsDefinition.onappterminate = newTerminateFunction;\n                            }\n                        }\n                    }\n                    return oldImplementation(eventsDefinition);\n                }\n                kony.application.setApplicationCallbacks = newImplementation;\n                if (deviceInfo.name !== \"thinclient \") {\n                    var callbackEvents = {\n                        onforeground: function() {},\n                        onbackground: function() {},\n                        onappterminate: function() {}\n                    };\n\n                    kony.application.setApplicationCallbacks(callbackEvents);\n                }\n        }\n\n        /*\n         *  Name      : kony.license.invokeServiceAsyncOverride\n         *  Author    : None\n         *  Purpose   : Overrides the API invokeServiceAsync. Appends tracking keys to the input param.\n         */\n        kony.license.invokeServiceAsyncOverride = function() {\n                kony.license.log(\"overriding kony.net.invokeServiceAsync..\");\n                var oldImplementation = kony.net.invokeServiceAsync;\n\n                function newImplementation(url, input, callback, config, requestType, reportData) {\n                    if (kony.license.isCloud() === true) {\n                        if (input === undefined || input === null) {\n                            input = {};\n                        }\n                        if (input !== undefined && input !== null && !isGetRequest(input)) {\n                            if (requestType !== undefined && requestType !== null) {\n                                input.konyreportingparams = processKonyReportingParams(input.konyreportingparams, requestType, reportData);\n                            } else {\n                                input.konyreportingparams = processKonyReportingParams(input.konyreportingparams, null, null);\n                            }\n                        }\n                    }\n                    return oldImplementation(url, input, callback, config);\n\n                    function processKonyReportingParams(params, requestType, reportData) {\n                      ","  var params2 = kony.license.appendLicenseTrackingKeys(requestType, reportData);\n                        if (!params) {\n                            return JSON.stringify(params2);\n                        } else {\n                            try {\n                                if (typeof(params) === \"string\") {\n                                    params = JSON.parse(params);\n                                }\n                                for (var key in params2) {\n                                    if (typeof(params[key]) === \"undefined\") {\n                                        params[key] = params2[key];\n                                    }\n                                }\n                                return JSON.stringify(params);\n                            } catch (e) {\n                                kony.license.log(\"unable to parse params \" + params);\n                                return JSON.stringify(params2);\n                            }\n\n\n                        }\n                    }\n\n                    function isGetRequest(inputParams) {\n                        if (inputParams && inputParams.httpconfig && inputParams.httpconfig.method && inputParams.httpconfig.method === \"get\") {\n                            return true;\n                        }\n                        return false;\n                    }\n                }\n                kony.net.invokeServiceAsync = newImplementation;\n        }\n\n        /*\n         *  Name      : kony.license.invokeServiceSyncOverride\n         *  Author    : None\n         *  Purpose   : Overrides the API invokeServiceSync. Appends tracking keys to the input param.\n         */\n        kony.license.invokeServiceSyncOverride = function() {\n                kony.license.log(\"overriding kony.net.invokeServiceSync..\");\n                var oldImplementation = kony.net.invokeServiceSync;\n\n                function newImplementation(url, input, isblocking) {\n                    if (kony.license.isCloud() === true) {\n                        if (input === undefined || input === null) {\n                            input = {};\n                        }\n                        if (input !== undefined && input !== null) {\n                            input.konyreportingparams = JSON.stringify(kony.license.appendLicenseTrackingKeys(null));\n                        }\n                    }\n                    return oldImplementation(url, input, isblocking);\n                }\n                kony.net.invokeServiceSync = newImplementation;\n        }\n\n        /*\n         *  Name      : kony.license.setAppInitializationEventsOverride\n         *  Author    : None\n         *  Purpose   : Overrides the API setApplicationInitializationEvents. Prepends postappinit event with required session tracking method.\n         *              If postappinit is undefiend, sets postappinit with required session tracking method.\n         */\n        kony.license.setAppInitializationEventsOverride = function() {\n                var oldImplementation = kony.application.setApplicationInitializationEvents;\n                function newImplementation(eventsDefinition) {\n                    kony.license.log(\"setApplicationInitializationEvents events \" + eventsDefinition);\n                    if (kony.license.isCloud() === true) {\n                        if (eventsDefinition !== undefined && eventsDefinition !== null) {\n                            if (eventsDefinition.postappinit !== undefined && eventsDefinition.postappinit !== null) {\n                                var userFunction = eventsDefinition.postappinit;\n                                var newFunction = function() {\n                                    kony.license.captureKonyLicenseUsage(true);\n                                    var userForm = userFunction.apply(this,arguments);\n                                    if (userForm !== undefined || userForm !== null) {\n                                        return userForm;\n                                    }\n                                };\n                                eventsDefinition.postappinit = newFunction;\n                            } else {\n                                var newFunction = function() {\n                                    kony.license.captureKonyLicenseUsage(true);\n                                };\n                                eventsDefinition.postappinit = newFunction;\n                            }\n                        }\n                    }\n                    return oldImplementation(eventsDefinition);\n                }\n                kony.application.setApplicationInitializationEvents = newImplementation;\n        }\n        /*\n         *  Name      : kony.license.apiOverride\n         *  Author    : None\n         *  Purpose   : Sets initial application callbacks. Calls the API overriding functions\n         */\n       kony.license.apiOverride =function() {\n                kony.license.log(\"Entering apiOverride..\");\n                //Overriding APIs\n                if (deviceInfo.name !== \"thinclient\") {\n                    kony.license.setAppCallbacksOverride();\n                }\n                kony.license.invokeServiceAsyncOverride();\n                kony.license.invokeServiceSyncOverride();\n                kony.license.setAppInitializationEventsOverride();\n        }\n\n        kony.license.apiOverride();\n        if (deviceInfo.name !== \"thinclient\") {\n            Object.seal(kony.license);\n            Object.freeze(kony.license);\n        }\n        kony.license.log(\"license loading completed\");\n}\n\n//License Network Layer\nkony.license.invokeIST = function(url, params, successCallback, failureCallback, options) {\n    if(typeof(url)===\"undefined\" || url === undefined || url === null || url === \"\"){\n        failureCallback(\"license url can't be null or empty\");\n        return;\n    }\n\n    var headers = {\"Content-Type\":\"application/x-www-form-urlencoded\"};\n    //kony.sdk can be undefined in case where sdk is absent in project eg.(fp apps of 7.x versions) or unable to load\n    if(kony.hasOwnProperty(\"sdk\") && kony.sdk.getCurrentInstance && kony.sdk.getCurrentInstance()){\n        url = kony.sdk.getCurrentInstance().appendGlobalParams(url, headers, params);\n    }\n\n    var httpRequest = new kony.net.HttpRequest();\n    if(options && options[\"httpRequestOptions\"] && options[\"httpRequestOptions\"] instanceof Object && options[\"httpRequestOptions\"][\"timeoutIntervalForRequest\"]){\n        httpRequest.timeout = options[\"httpRequestOptions\"][\"timeoutIntervalForRequest\"] * 1000;\n    }\n    httpRequest.open(\"POST\", url);\n\n    function localRequestCallback(result) {\n        var readyState = Number(httpRequest.readyState.toString());\n        var status = Number(httpRequest.status.toString());\n        kony.license.log(\"localRequestCallback in state :\"+readyState+\" with status :\"+status);\n        var response = null;\n        if (readyState === 4) {\n            var isFailure = true;\n            if ((status >= 200 && status < 300)|| status === 504) {\n                if (status!== 504){\n                    try{\n                        response = JSON.parse(JSON.stringify(httpRequest.response)); //copying response\n                        if(typeof(response) === \"string\"){\n                            response = JSON.parse(response);\t\n                        }\n                        if(response && (typeof(response.opstatus) === \"undefined\" || response.opstatus == 0)){\n                            isFailure = false;\n                        }\n                    } catch (e){\n                        kony.license.log(\"error while extracting response :\"+e);\n                    } \n                } else{\n                    isFailure = false;\n                }\n            }\n            if( isFailure === true){\n                failureCallback({\"error\":\"failure in sending IST call with status as :\"+status});\n            } else{\n                successCallback(response);\n            }\n        }\n    }\n\n    //setting params\n    paramsTable = new kony.net.FormData();\n    for (var key in params) {\n        if (typeof(params[key]) != \"undefined\") {\n            if (typeof(params[key]) !== \"string\") {\n                params[key] = JSON.stringify(params[key]);\n            }\n            paramsTable.append((key), (params[key]));\n        }\n    }\n    kony.license.log(\"paramsTable formed is \"+paramsTable.toString());\n    //setting headers\n    for (var headerKey in headers ) {\n        if(headers.hasOwnProperty(headerKey)){\n            httpRequest.setRequestHeader(headerKey , headers[headerKey]);\n        }\n    }   \n    //setting listener\n    httpRequest.onReadyStateChange = localRequestCallback;\n    //sending IST\n    httpRequest.send(paramsTable);\n    \n}\n\n\nfunction cloudSessionCallback() {\n    kony.license.log(\"Cloud session timed out.\");\n    kony.ds.remove(\"konyLastAccessTime\");\n    kony.ds.remove(\"konyUUID\");\n    kony.ds.remove(\"konyCustomReportData\");\n    kony.ds.remove(\"konyOfflineAccessData\");\n    kony.license.captureKonyLicenseUsage();\n    kony.cloud.appevents.unregisterforidletimeout();\n    kony.cloud.appevents.registerforidletimeout(30, cloudSessionCallback);\n}\n\nkony.license.startLicenseService();"};
	}
}